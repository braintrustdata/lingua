//! Schema Converter Module
//!
//! This module contains utilities for converting JSON Schema types to Rust code.

use big_serde_json as serde_json;

/// Convert a JSON Schema type to its Rust equivalent
pub fn schema_type_to_rust(
    prop_schema: &serde_json::Value,
    _all_schemas: &serde_json::Map<String, serde_json::Value>,
) -> String {
    // Handle $ref by using serde_json::Value - this avoids dependency on types
    // that may or may not be generated by the main quicktype pass.
    // The types will still serialize/deserialize correctly with serde.
    if prop_schema.get("$ref").is_some() {
        return "serde_json::Value".to_string();
    }

    // Handle anyOf/oneOf - usually means nullable or union, use Value for flexibility
    if prop_schema.get("anyOf").is_some() || prop_schema.get("oneOf").is_some() {
        // Check if it's a simple nullable type (anyOf with null)
        if let Some(any_of) = prop_schema.get("anyOf").and_then(|a| a.as_array()) {
            let non_null: Vec<_> = any_of
                .iter()
                .filter(|v| v.get("type").and_then(|t| t.as_str()) != Some("null"))
                .collect();
            if non_null.len() == 1 {
                return schema_type_to_rust(non_null[0], _all_schemas);
            }
        }
        return "serde_json::Value".to_string();
    }

    // Handle const/enum - typically a single-value enum for type discriminators
    if prop_schema.get("const").is_some() || prop_schema.get("enum").is_some() {
        return "String".to_string();
    }

    match prop_schema.get("type").and_then(|t| t.as_str()) {
        Some("string") => "String".to_string(),
        Some("integer") => "i64".to_string(),
        Some("number") => "f64".to_string(),
        Some("boolean") => "bool".to_string(),
        Some("array") => {
            let item_type = prop_schema
                .get("items")
                .map(|i| schema_type_to_rust(i, _all_schemas))
                .unwrap_or_else(|| "serde_json::Value".to_string());
            format!("Vec<{}>", item_type)
        }
        Some("object") => {
            // Check if it has specific properties (structured object) or is freeform
            if prop_schema.get("properties").is_some() {
                // This is a nested object with known structure - use Value for now
                // Could generate inline struct, but adds complexity
                "serde_json::Value".to_string()
            } else {
                // Freeform object
                "serde_json::Map<String, serde_json::Value>".to_string()
            }
        }
        Some("null") => "()".to_string(),
        _ => "serde_json::Value".to_string(),
    }
}

/// Convert a property name to a valid Rust field name (snake_case)
pub fn to_rust_field_name(name: &str) -> String {
    // Handle reserved words
    let reserved = [
        "type", "ref", "self", "super", "crate", "mod", "use", "fn", "impl", "trait",
    ];

    let snake = to_snake_case(name);

    if reserved.contains(&snake.as_str()) {
        format!("r#{}", snake)
    } else {
        snake
    }
}

/// Convert camelCase or PascalCase to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}
