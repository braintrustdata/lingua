/*!
OpenAI chat completion response types.

These types match the OpenAI TypeScript SDK exactly, extracted from the latest version.
All fields and nested types are preserved to ensure full API compatibility.
*/

use super::request::{ChatCompletionMessageToolCall, ServiceTier};
use serde::{Deserialize, Serialize};

/// Main chat completion response
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletion {
    /// Unique identifier for the chat completion
    pub id: String,

    /// List of completion choices
    pub choices: Vec<ChatCompletionChoice>,

    /// Unix timestamp of creation
    pub created: u64,

    /// Model used for completion
    pub model: String,

    /// Object type (always "chat.completion")
    pub object: String,

    /// Service tier used for processing
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_tier: Option<ServiceTier>,

    /// Backend configuration fingerprint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_fingerprint: Option<String>,

    /// Token usage statistics
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<CompletionUsage>,
}

/// Individual completion choice
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionChoice {
    /// Reason why completion finished
    pub finish_reason: FinishReason,

    /// Index of this choice
    pub index: u32,

    /// Log probability information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logprobs: Option<ChoiceLogprobs>,

    /// Chat completion message
    pub message: ChatCompletionMessage,
}

/// Log probability information for a choice
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChoiceLogprobs {
    /// Content token log probabilities
    pub content: Option<Vec<ChatCompletionTokenLogprob>>,

    /// Refusal token log probabilities
    pub refusal: Option<Vec<ChatCompletionTokenLogprob>>,
}

/// Token log probability information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionTokenLogprob {
    /// The token
    pub token: String,

    /// UTF-8 bytes representation
    pub bytes: Option<Vec<u32>>,

    /// Log probability of this token
    pub logprob: f64,

    /// Most likely alternative tokens
    pub top_logprobs: Vec<TokenLogprob>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TokenLogprob {
    /// The token
    pub token: String,

    /// UTF-8 bytes representation
    pub bytes: Option<Vec<u32>>,

    /// Log probability of this token
    pub logprob: f64,
}

/// Chat completion message from the model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionMessage {
    /// Message content
    pub content: Option<String>,

    /// Refusal message
    pub refusal: Option<String>,

    /// Message role (always "assistant")
    pub role: String,

    /// Message annotations (e.g., from web search)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotations: Option<Vec<MessageAnnotation>>,

    /// Audio response data
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio: Option<ChatCompletionAudio>,

    /// Deprecated function call
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_call: Option<MessageFunctionCall>,

    /// Tool calls generated by the model
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ChatCompletionMessageToolCall>>,
}

/// Message annotation (e.g., URL citations)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum MessageAnnotation {
    #[serde(rename = "url_citation")]
    UrlCitation(UrlCitationAnnotation),
}

/// URL citation annotation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UrlCitationAnnotation {
    /// URL citation details
    pub url_citation: UrlCitation,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UrlCitation {
    /// End index of citation in message
    pub end_index: u32,
    /// Start index of citation in message
    pub start_index: u32,
    /// Title of the web resource
    pub title: String,
    /// URL of the web resource
    pub url: String,
}

/// Audio response data
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionAudio {
    /// Audio response ID
    pub id: String,
    /// Base64 encoded audio data
    pub data: String,
    /// Unix timestamp when audio expires
    pub expires_at: u64,
    /// Audio transcript
    pub transcript: String,
}

/// Deprecated function call in message
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MessageFunctionCall {
    /// Function arguments
    pub arguments: String,
    /// Function name
    pub name: String,
}

/// Token usage statistics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CompletionUsage {
    /// Number of tokens in the prompt
    pub prompt_tokens: u32,

    /// Number of tokens in the completion
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completion_tokens: Option<u32>,

    /// Total number of tokens
    pub total_tokens: u32,

    /// Detailed token usage breakdown
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completion_tokens_details: Option<CompletionTokensDetails>,

    /// Detailed prompt token usage breakdown
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt_tokens_details: Option<PromptTokensDetails>,
}

/// Detailed completion token usage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CompletionTokensDetails {
    /// Audio tokens in completion
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio_tokens: Option<u32>,

    /// Reasoning tokens used
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning_tokens: Option<u32>,

    /// Text output tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text_tokens: Option<u32>,
}

/// Detailed prompt token usage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptTokensDetails {
    /// Audio tokens in prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio_tokens: Option<u32>,

    /// Cached tokens in prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_tokens: Option<u32>,

    /// Text tokens in prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text_tokens: Option<u32>,
}

/// Reason why the model stopped generating
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FinishReason {
    /// Natural stop point or provided stop sequence
    Stop,
    /// Maximum token limit reached
    Length,
    /// Model called a tool
    ToolCalls,
    /// Content filtered
    ContentFilter,
    /// Model called a function (deprecated)
    FunctionCall,
}

/// Streaming chat completion chunk
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionChunk {
    /// Unique identifier (same across all chunks)
    pub id: String,

    /// List of choice deltas
    pub choices: Vec<ChatCompletionChunkChoice>,

    /// Unix timestamp (same across all chunks)
    pub created: u64,

    /// Model used for completion
    pub model: String,

    /// Object type (always "chat.completion.chunk")
    pub object: String,

    /// Service tier used for processing
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_tier: Option<ServiceTier>,

    /// Backend configuration fingerprint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_fingerprint: Option<String>,

    /// Usage statistics (only in final chunk)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<CompletionUsage>,
}

/// Individual streaming choice
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionChunkChoice {
    /// Delta information for this chunk
    pub delta: ChatCompletionChunkDelta,

    /// Reason why completion finished
    pub finish_reason: Option<FinishReason>,

    /// Index of this choice
    pub index: u32,

    /// Log probability information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logprobs: Option<ChoiceLogprobs>,
}

/// Delta information in streaming chunk
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionChunkDelta {
    /// Content chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// Deprecated function call chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_call: Option<DeltaFunctionCall>,

    /// Refusal chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refusal: Option<String>,

    /// Role (only in first chunk)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,

    /// Tool call deltas
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<DeltaToolCall>>,
}

/// Function call delta (deprecated)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeltaFunctionCall {
    /// Function arguments chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<String>,

    /// Function name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Tool call delta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeltaToolCall {
    /// Tool call index
    pub index: u32,

    /// Tool call ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Function delta
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function: Option<DeltaToolCallFunction>,

    /// Tool type
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub tool_type: Option<String>,
}

/// Function delta in tool call
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeltaToolCallFunction {
    /// Function arguments chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<String>,

    /// Function name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Deleted chat completion response
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionDeleted {
    /// ID of deleted completion
    pub id: String,

    /// Whether deletion was successful
    pub deleted: bool,

    /// Object type
    pub object: String,
}

/// Stored chat completion message (extends ChatCompletionMessage)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChatCompletionStoreMessage {
    /// Message ID
    pub id: String,

    /// Message content
    pub content: Option<String>,

    /// Refusal message
    pub refusal: Option<String>,

    /// Message role
    pub role: String,

    /// Content parts array if provided
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_parts: Option<Vec<ContentPart>>,

    /// Message annotations
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotations: Option<Vec<MessageAnnotation>>,

    /// Audio response data
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio: Option<ChatCompletionAudio>,

    /// Deprecated function call
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_call: Option<MessageFunctionCall>,

    /// Tool calls
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ChatCompletionMessageToolCall>>,
}

/// Content part for stored messages
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ContentPart {
    #[serde(rename = "text")]
    Text(TextContentPart),
    #[serde(rename = "image_url")]
    ImageUrl(ImageUrlContentPart),
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TextContentPart {
    pub text: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageUrlContentPart {
    pub image_url: ImageUrlInfo,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageUrlInfo {
    pub url: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
}
